// Generated by typings
// Source: https://raw.githubusercontent.com/types/typed-redis/8d0f9f0d57c05cef5d7a592cde31fa973aa0e6f0/index.d.ts
declare module 'redis' {
import { EventEmitter } from 'events';
import { Duplex } from 'stream';

namespace redis {
  export interface ClientOptions {
    host?: string;
    port?: number;
    path?: string;
    url?: string;
    parser?: string;
    string_numbers?: boolean;
    return_buffers?: boolean;
    detect_buffers?: boolean;
    socket_keepalive?: boolean;
    no_ready_check?: boolean;
    enable_offline_queue?: boolean;
    retry_max_delay?: number;
    connect_timeout?: number;
    max_attempts?: number;
    retry_unfulfilled_commands?: boolean;
    auth_pass?: string;
    password?: string;
    db?: string;
    family?: string;
    rename_commands?: { [command: string]: string };
    tls?: any;
    prefix?: string;
    retry_strategy?: Function;
  }

  export interface Callback <T> {
    (err: Error | void, reply: T): void;
  }

  export interface ServerInfo {
    redis_version: string;
    versions: number[];
  }

  export interface OverloadedCommand <T, U, R> {
    (args: T[], cb?: Callback<U>): R;
    (arg: T, args: T[], cb?: Callback<U>): R;

    (arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, arg6: T, cb?: Callback<U>): R;
    (arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, cb?: Callback<U>): R;
    (arg1: T, arg2: T, arg3: T, arg4: T, cb?: Callback<U>): R;
    (arg1: T, arg2: T, arg3: T, cb?: Callback<U>): R;
    (arg1: T, arg2: T, cb?: Callback<U>): R;
    (arg1: T, cb?: Callback<U>): R;
    (...args: (T | Callback<U>)[]): R;
  }

  export interface OverloadedKeyCommand <T, U, R> {
    (key: string, args: T[], cb?: Callback<U>): R;

    (key: string, arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, arg6: T, cb?: Callback<U>): R;
    (key: string, arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, cb?: Callback<U>): R;
    (key: string, arg1: T, arg2: T, arg3: T, arg4: T, cb?: Callback<U>): R;
    (key: string, arg1: T, arg2: T, arg3: T, cb?: Callback<U>): R;
    (key: string, arg1: T, arg2: T, cb?: Callback<U>): R;
    (key: string, arg1: T, cb?: Callback<U>): R;
    (key: string, ...args: (T | Callback<U>)[]): R;
    (...args: (string | T | Callback<U>)[]): R;
  }

  export interface OverloadedListCommand <T, U, R> {
    (args: T[], cb?: Callback<U>): R;

    (arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, arg6: T, cb?: Callback<U>): R;
    (arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, cb?: Callback<U>): R;
    (arg1: T, arg2: T, arg3: T, arg4: T, cb?: Callback<U>): R;
    (arg1: T, arg2: T, arg3: T, cb?: Callback<U>): R;
    (arg1: T, arg2: T, cb?: Callback<U>): R;
    (arg1: T, cb?: Callback<U>): R;
    (...args: (T | Callback<U>)[]): R;
  }

  export interface OverloadedSetCommand <T, U, R> {
    (key: string, arg: { [key: string]: T }, cb?: Callback<U>): R;
    (key: string, args: T[], cb?: Callback<U>): R;

    (key: string, arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, arg6: T, cb?: Callback<U>): R;
    (key: string, arg1: T, arg2: T, arg3: T, arg4: T, arg5: T, cb?: Callback<U>): R;
    (key: string, arg1: T, arg2: T, arg3: T, arg4: T, cb?: Callback<U>): R;
    (key: string, arg1: T, arg2: T, arg3: T, cb?: Callback<U>): R;
    (key: string, arg1: T, arg2: T, cb?: Callback<U>): R;
    (key: string, arg1: T, cb?: Callback<U>): R;
    (key: string, ...args: (T | Callback<U>)[]): R;
  }

  export interface OverloadedLastCommand <T1, T2, U, R> {
    (args: (T1 | T2)[], cb?: Callback<U>): R;
    (arg: T1, args: (T1 | T2)[], cb?: Callback<U>): R;

    (arg1: T1, arg2: T1, arg3: T1, arg4: T1, arg5: T1, arg6: T2, cb?: Callback<U>): R;
    (arg1: T1, arg2: T1, arg3: T1, arg4: T1, arg5: T2, cb?: Callback<U>): R;
    (arg1: T1, arg2: T1, arg3: T1, arg4: T2, cb?: Callback<U>): R;
    (arg1: T1, arg2: T1, arg3: T2, cb?: Callback<U>): R;
    (arg1: T1, arg2: T2, cb?: Callback<U>): R;
    (...args: (T1 | T2 | Callback<U>)[]): R;
  }

  export interface Commands <R> {
    /**
     * Listen for all requests received by the server in real time.
     */
    monitor (cb?: Callback<void>): R;
    monitorAsync (): Promise<void>;//#
    MONITOR (cb?: Callback<void>): R;
    MONITORAsync (): Promise<void>;//#

    /**
     * Get information and statistics about the server.
     */
    info (cb?: Callback<ServerInfo>): R;
    infoAsync (): Promise<ServerInfo>;//#
    info (section?: string | string[], cb?: Callback<ServerInfo>): R;
    infoAsync (section?: string | string[]): Promise<ServerInfo>;//#
    INFO (cb?: Callback<ServerInfo>): R;
    INFOAsync (): Promise<ServerInfo>;//#
    INFO (section?: string | string[], cb?: Callback<ServerInfo>): R;
    INFOAsync (section?: string | string[]): Promise<ServerInfo>;//#

    /**
     * Ping the server.
     */
    ping (callback?: Callback<string>): R;
    ping (message: string, callback?: Callback<string>): R;

    /**
     * Post a message to a channel.
     */
    publish (channel: string, value: string, cb?: Callback<number>): R;
    publishAsync (channel: string, value: string): Promise<number>;//#

    /**
     * Authenticate to the server.
     */
    auth (password: string, callback?: Callback<string>): R;
    AUTH (password: string, callback?: Callback<string>): R;

    /**
     * KILL - Kill the connection of a client.
     * LIST - Get the list of client connections.
     * GETNAME - Get the current connection name.
     * PAUSE - Stop processing commands from clients for some time.
     * REPLY - Instruct the server whether to reply to commands.
     * SETNAME - Set the current connection name.
     */
    client: OverloadedCommand<string, any, R>;
    CLIENT: OverloadedCommand<string, any, R>;

    /**
     * Set multiple hash fields to multiple values.
     */
    hmset: OverloadedSetCommand<string | number, boolean, R>;
    HMSET: OverloadedSetCommand<string | number, boolean, R>;

    /**
     * Listen for messages published to the given channels.
     */
    subscribe: OverloadedListCommand<string, string, R>;
    SUBSCRIBE: OverloadedListCommand<string, string, R>;

    /**
     * Stop listening for messages posted to the given channels.
     */
    unsubscribe: OverloadedListCommand<string, string, R>;
    UNSUBSCRIBE: OverloadedListCommand<string, string, R>;

    /**
     * Listen for messages published to channels matching the given patterns.
     */
    psubscribe: OverloadedListCommand<string, string, R>;
    PSUBSCRIBE: OverloadedListCommand<string, string, R>;

    /**
     * Stop listening for messages posted to channels matching the given patterns.
     */
    punsubscribe: OverloadedListCommand<string, string, R>;
    PUNSUBSCRIBE: OverloadedListCommand<string, string, R>;

    /**
     * Append a value to a key.
     */
    append (key: string, value: string, cb?: Callback<number>): R;
    appendAsync (key: string, value: string): Promise<number>;//#
    APPEND (key: string, value: string, cb?: Callback<number>): R;
    APPENDAsync (key: string, value: string): Promise<number>;//#

    /**
     * Asynchronously rewrite the append-only file.
     */
    bgrewriteaof (cb?: Callback<'OK'>): R;
    bgrewriteaofAsync (): Promise<'OK'>;//#
    BGREWRITEAOF (cb?: Callback<'OK'>): R;
    BGREWRITEAOFAsync (): Promise<'OK'>;//#

    /**
     * Asynchronously save the dataset to disk.
     */
    bgsave (cb?: Callback<string>): R;
    bgsaveAsync (): Promise<string>;//#
    BGSAVE (cb?: Callback<string>): R;
    BGSAVEAsync (): Promise<string>;//#

    /**
     * Count set bits in a string.
     */
    bitcount (key: string, cb?: Callback<number>): R;
    bitcountAsync (key: string): Promise<number>;//#
    bitcount (key: string, start: number, end: number, cb?: Callback<number>): R;
    bitcountAsync (key: string, start: number, end: number): Promise<number>;//#
    BITCOUNT (key: string, cb?: Callback<number>): R;
    BITCOUNTAsync (key: string): Promise<number>;//#
    BITCOUNT (key: string, start: number, end: number, cb?: Callback<number>): R;
    BITCOUNTAsync (key: string, start: number, end: number): Promise<number>;//#

    /**
     * Perform arbitrary bitfield integer operations on strings.
     */
    bitfield: OverloadedKeyCommand<string | number, [number, number], R>;
    BITFIELD: OverloadedKeyCommand<string | number, [number, number], R>;

    /**
     * Perform bitwise operations between strings.
     */
    bitop (operation: string, destkey: string, key1: string, key2: string, key3: string, cb?: Callback<number>): R;
    bitopAsync (operation: string, destkey: string, key1: string, key2: string, key3: string): Promise<number>;//#
    bitop (operation: string, destkey: string, key1: string, key2: string, cb?: Callback<number>): R;
    bitopAsync (operation: string, destkey: string, key1: string, key2: string): Promise<number>;//#
    bitop (operation: string, destkey: string, key: string, cb?: Callback<number>): R;
    bitopAsync (operation: string, destkey: string, key: string): Promise<number>;//#
    bitop (operation: string, destkey: string, ...args: (string | Callback<number>)[]): R;
    BITOP (operation: string, destkey: string, key1: string, key2: string, key3: string, cb?: Callback<number>): R;
    BITOPAsync (operation: string, destkey: string, key1: string, key2: string, key3: string): Promise<number>;//#
    BITOP (operation: string, destkey: string, key1: string, key2: string, cb?: Callback<number>): R;
    BITOPAsync (operation: string, destkey: string, key1: string, key2: string): Promise<number>;//#
    BITOP (operation: string, destkey: string, key: string, cb?: Callback<number>): R;
    BITOPAsync (operation: string, destkey: string, key: string): Promise<number>;//#
    BITOP (operation: string, destkey: string, ...args: (string | Callback<number>)[]): R;

    /**
     * Find first bit set or clear in a string.
     */
    bitpos (key: string, bit: number, start: number, end: number, cb?: Callback<number>): R;
    bitposAsync (key: string, bit: number, start: number, end: number): Promise<number>;//#
    bitpos (key: string, bit: number, start: number, cb?: Callback<number>): R;
    bitposAsync (key: string, bit: number, start: number): Promise<number>;//#
    bitpos (key: string, bit: number, cb?: Callback<number>): R;
    bitposAsync (key: string, bit: number): Promise<number>;//#
    BITPOS (key: string, bit: number, start: number, end: number, cb?: Callback<number>): R;
    BITPOSAsync (key: string, bit: number, start: number, end: number): Promise<number>;//#
    BITPOS (key: string, bit: number, start: number, cb?: Callback<number>): R;
    BITPOSAsync (key: string, bit: number, start: number): Promise<number>;//#
    BITPOS (key: string, bit: number, cb?: Callback<number>): R;
    BITPOSAsync (key: string, bit: number): Promise<number>;//#

    /**
     * Remove and get the first element in a list, or block until one is available.
     */
    blpop: OverloadedLastCommand<string, number, [string, string], R>;
    BLPOP: OverloadedLastCommand<string, number, [string, string], R>;

    /**
     * Remove and get the last element in a list, or block until one is available.
     */
    brpop: OverloadedLastCommand<string, number, [string, string], R>;
    BRPOP: OverloadedLastCommand<string, number, [string, string], R>;

    /**
     * Pop a value from a list, push it to another list and return it; or block until one is available.
     */
    brpoplpush (source: string, destination: string, timeout: number, cb?: Callback<[string, string]>): R;
    brpoplpushAsync (source: string, destination: string, timeout: number): Promise<[string, string]>;//#
    BRPOPLPUSH (source: string, destination: string, timeout: number, cb?: Callback<[string, string]>): R;
    BRPOPLPUSHAsync (source: string, destination: string, timeout: number): Promise<[string, string]>;//#

    /**
     * ADDSLOTS - Assign new hash slots to receiving node.
     * COUNT-FAILURE-REPORTS - Return the number of failure reports active for a given node.
     * COUNTKEYSINSLOT - Return the number of local keys in the specified hash slot.
     * DELSLOTS - Set hash slots as unbound in receiving node.
     * FAILOVER - Forces a slave to perform a manual failover of its master.
     * FORGET - Remove a node from the nodes table.
     * GETKEYSINSLOT - Return local key names in the specified hash slot.
     * INFO - Provides info about Redis Cluster node state.
     * KEYSLOT - Returns the hash slot of the specified key.
     * MEET - Force a node cluster to handshake with another node.
     * NODES - Get cluster config for the node.
     * REPLICATE - Reconfigure a node as a slave of the specified master node.
     * RESET - Reset a Redis Cluster node.
     * SAVECONFIG - Forces the node to save cluster state on disk.
     * SET-CONFIG-EPOCH - Set the configuration epoch in a new node.
     * SETSLOT - Bind a hash slot to a specified node.
     * SLAVES - List slave nodes of the specified master node.
     * SLOTS - Get array of Cluster slot to node mappings.
     */
    cluster: OverloadedCommand<string, any, this>;
    CLUSTER: OverloadedCommand<string, any, this>;

    /**
     * Get array of Redis command details.
     *
     * COUNT - Get total number of Redis commands.
     * GETKEYS - Extract keys given a full Redis command.
     * INFO - Get array of specific REdis command details.
     */
    command (cb?: Callback<Array<[string, number, string[], number, number, number]>>): R;
    commandAsync (): Promise<Array<[string, number, string[], number, number, number]>;//#
    COMMAND (cb?: Callback<Array<[string, number, string[], number, number, number]>>): R;
    COMMANDAsync (): Promise<Array<[string, number, string[], number, number, number]>;//#

    /**
     * Get array of Redis command details.
     *
     * COUNT - Get array of Redis command details.
     * GETKEYS - Extract keys given a full Redis command.
     * INFO - Get array of specific Redis command details.
     * GET - Get the value of a configuration parameter.
     * REWRITE - Rewrite the configuration file with the in memory configuration.
     * SET - Set a configuration parameter to the given value.
     * RESETSTAT - Reset the stats returned by INFO.
     */
    config: OverloadedCommand<string, boolean, R>;
    CONFIG: OverloadedCommand<string, boolean, R>;

    /**
     * Return the number of keys in the selected database.
     */
    dbsize (cb?: Callback<number>): R;
    dbsizeAsync (): Promise<number>;//#
    DBSIZE (cb?: Callback<number>): R;
    DBSIZEAsync (): Promise<number>;//#

    /**
     * OBJECT - Get debugging information about a key.
     * SEGFAULT - Make the server crash.
     */
    debug: OverloadedCommand<string, boolean, R>;
    DEBUG: OverloadedCommand<string, boolean, R>;

    /**
     * Decrement the integer value of a key by one.
     */
    decr (key: string, cb?: Callback<number>): R;
    decrAsync (key: string): Promise<number>;//#
    DECR (key: string, cb?: Callback<number>): R;
    DECRAsync (key: string): Promise<number>;//#

    /**
     * Decrement the integer value of a key by the given number.
     */
    decrby (key: string, decrement: number, cb?: Callback<number>): R;
    decrbyAsync (key: string, decrement: number): Promise<number>;//#
    DECRBY (key: string, decrement: number, cb?: Callback<number>): R;
    DECRBYAsync (key: string, decrement: number): Promise<number>;//#

    /**
     * Delete a key.
     */
    del: OverloadedCommand<string, number, R>;
    DEL: OverloadedCommand<string, number, R>;

    /**
     * Discard all commands issued after MULTI.
     */
    discard (cb?: Callback<'OK'>): R;
    discardAsync (): Promise<'OK'>;//#
    DISCARD (cb?: Callback<'OK'>): R;
    DISCARDAsync (): Promise<'OK'>;//#

    /**
     * Return a serialized version of the value stored at the specified key.
     */
    dump (key: string, cb?: Callback<string>): R;
    dumpAsync (key: string): Promise<string>;//#
    DUMP (key: string, cb?: Callback<string>): R;
    DUMPAsync (key: string): Promise<string>;//#

    /**
     * Echo the given string.
     */
    echo <T extends string> (message: T, cb?: Callback<T>): R;
    echoAsync <T extends string> (message: T): Promise<T>;//#
    ECHO <T extends string> (message: T, cb?: Callback<T>): R;
    ECHOAsync <T extends string> (message: T): Promise<T>;//#

    /**
     * Execute a Lua script server side.
     */
    eval: OverloadedCommand<string | number, any, R>;
    EVAL: OverloadedCommand<string | number, any, R>;

    /**
     * Execute a Lue script server side.
     */
    evalsha: OverloadedCommand<string | number, any, R>;
    EVALSHA: OverloadedCommand<string | number, any, R>;

    /**
     * Determine if a key exists.
     */
    exists: OverloadedCommand<string, number, R>;
    EXISTS: OverloadedCommand<string, number, R>;

    /**
     * Set a key's time to live in seconds.
     */
    expire (key: string, seconds: number, cb?: Callback<number>): R;
    expireAsync (key: string, seconds: number): Promise<number>;//#
    EXPIRE (key: string, seconds: number, cb?: Callback<number>): R;
    EXPIREAsync (key: string, seconds: number): Promise<number>;//#

    /**
     * Set the expiration for a key as a UNIX timestamp.
     */
    expireat (key: string, timestamp: number, cb?: Callback<number>): R;
    expireatAsync (key: string, timestamp: number): Promise<number>;//#
    EXPIREAT (key: string, timestamp: number, cb?: Callback<number>): R;
    EXPIREATAsync (key: string, timestamp: number): Promise<number>;//#

    /**
     * Remove all keys from all databases.
     */
    flushall (cb?: Callback<string>): R;
    flushallAsync (): Promise<string>;//#
    FLUSHALL (cb?: Callback<string>): R;
    FLUSHALLAsync (): Promise<string>;//#

    /**
     * Remove all keys from the current database.
     */
    flushdb (cb?: Callback<string>): R;
    flushdbAsync (): Promise<string>;//#
    FLUSHDB (cb?: Callback<string>): R;
    FLUSHDBAsync (): Promise<string>;//#

    /**
     * Add one or more geospatial items in the geospatial index represented using a sorted set.
     */
    geoadd: OverloadedKeyCommand<string | number, number, R>;
    GEOADD: OverloadedKeyCommand<string | number, number, R>;

    /**
     * Returns members of a geospatial index as standard geohash strings.
     */
    geohash: OverloadedKeyCommand<string, string, R>;
    GEOHASH: OverloadedKeyCommand<string, string, R>;

    /**
     * Returns longitude and latitude of members of a geospatial index.
     */
    geopos: OverloadedKeyCommand<string, Array<[number, number]>, R>;
    GEOPOS: OverloadedKeyCommand<string, Array<[number, number]>, R>;

    /**
     * Returns the distance between two members of a geospatial index.
     */
    geodist: OverloadedKeyCommand<string, string, R>;
    GEODIST: OverloadedKeyCommand<string, string, R>;

    /**
     * Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point.
     */
    georadius: OverloadedKeyCommand<string | number, Array<string | [string, string | [string, string]]>, R>;
    GEORADIUS: OverloadedKeyCommand<string | number, Array<string | [string, string | [string, string]]>, R>;

    /**
     * Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member.
     */
    georadiusbymember: OverloadedKeyCommand<string | number, Array<string | [string, string | [string, string]]>, R>;
    GEORADIUSBYMEMBER: OverloadedKeyCommand<string | number, Array<string | [string, string | [string, string]]>, R>;

    /**
     * Get the value of a key.
     */
    get (key: string, cb?: Callback<string>): R;
    getAsync (key: string): Promise<string>;//#
    GET (key: string, cb?: Callback<string>): R;
    GETAsync (key: string): Promise<string>;//#

    /**
     * Returns the bit value at offset in the string value stored at key.
     */
    getbit (key: string, offset: number, cb?: Callback<number>): R;
    getbitAsync (key: string, offset: number): Promise<number>;//#
    GETBIT (key: string, offset: number, cb?: Callback<number>): R;
    GETBITAsync (key: string, offset: number): Promise<number>;//#

    /**
     * Get a substring of the string stored at a key.
     */
    getrange (key: string, start: number, end: number, cb?: Callback<string>): R;
    getrangeAsync (key: string, start: number, end: number): Promise<string>;//#
    GETRANGE (key: string, start: number, end: number, cb?: Callback<string>): R;
    GETRANGEAsync (key: string, start: number, end: number): Promise<string>;//#

    /**
     * Set the string value of a key and return its old value.
     */
    getset (key: string, value: string, cb?: Callback<string>): R;
    getsetAsync (key: string, value: string): Promise<string>;//#
    GETSET (key: string, value: string, cb?: Callback<string>): R;
    GETSETAsync (key: string, value: string): Promise<string>;//#

    /**
     * Delete on or more hash fields.
     */
    hdel: OverloadedKeyCommand<string, number, R>;
    HDEL: OverloadedKeyCommand<string, number, R>;

    /**
     * Determine if a hash field exists.
     */
    hexists (key: string, field: string, cb?: Callback<number>): R;
    hexistsAsync (key: string, field: string): Promise<number>;//#
    HEXISTS (key: string, field: string, cb?: Callback<number>): R;
    HEXISTSAsync (key: string, field: string): Promise<number>;//#

    /**
     * Get the value of a hash field.
     */
    hget (key: string, field: string, cb?: Callback<string>): R;
    hgetAsync (key: string, field: string): Promise<string>;//#
    HGET (key: string, field: string, cb?: Callback<string>): R;
    HGETAsync (key: string, field: string): Promise<string>;//#

    /**
     * Get all fields and values in a hash.
     */
    hgetall (key: string, cb: Callback<{ [key: string]: string }>): R;
    hgetallAsync (key: string): Promise<{ [key: string]: string }>;//#
    HGETALL (key: string, cb: Callback<{ [key: string]: string }>): R;
    HGETALLAsync (key: string): Promise<{ [key: string]: string }>;//#

    /**
     * Increment the integer value of a hash field by the given number.
     */
    hincrby (key: string, field: string, increment: number, cb?: Callback<number>): R;
    hincrbyAsync (key: string, field: string, increment: number): Promise<number>;//#
    HINCRBY (key: string, field: string, increment: number, cb?: Callback<number>): R;
    HINCRBYAsync (key: string, field: string, increment: number): Promise<number>;//#

    /**
     * Increment the float value of a hash field by the given amount.
     */
    hincrbyfloat (key: string, field: string, increment: number, cb?: Callback<number>): R;
    hincrbyfloatAsync (key: string, field: string, increment: number): Promise<number>;//#
    HINCRBYFLOAT (key: string, field: string, increment: number, cb?: Callback<number>): R;
    HINCRBYFLOATAsync (key: string, field: string, increment: number): Promise<number>;//#

    /**
     * Get all the fields of a hash.
     */
    hkeys (key: string, cb?: Callback<string[]>): R;
    hkeysAsync (key: string): Promise<string[]>;//#
    HKEYS (key: string, cb?: Callback<string[]>): R;
    HKEYSAsync (key: string): Promise<string[]>;//#

    /**
     * Get the number of fields in a hash.
     */
    hlen (key: string, cb?: Callback<number>): R;
    hlenAsync (key: string): Promise<number>;//#
    HLEN (key: string, cb?: Callback<number>): R;
    HLENAsync (key: string): Promise<number>;//#

    /**
     * Get the values of all the given hash fields.
     */
    hmget: OverloadedKeyCommand<string, string[], R>;
    HMGET: OverloadedKeyCommand<string, string[], R>;

    /**
     * Set the string value of a hash field.
     */
    hset (key: string, field: string, value: string, cb?: Callback<number>): R;
    hsetAsync (key: string, field: string, value: string): Promise<number>;//#
    HSET (key: string, field: string, value: string, cb?: Callback<number>): R;
    HSETAsync (key: string, field: string, value: string): Promise<number>;//#

    /**
     * Set the value of a hash field, only if the field does not exist.
     */
    hsetnx (key: string, field: string, value: string, cb?: Callback<number>): R;
    hsetnxAsync (key: string, field: string, value: string): Promise<number>;//#
    HSETNX (key: string, field: string, value: string, cb?: Callback<number>): R;
    HSETNXAsync (key: string, field: string, value: string): Promise<number>;//#

    /**
     * Get the length of the value of a hash field.
     */
    hstrlen (key: string, field: string, cb?: Callback<number>): R;
    hstrlenAsync (key: string, field: string): Promise<number>;//#
    HSTRLEN (key: string, field: string, cb?: Callback<number>): R;
    HSTRLENAsync (key: string, field: string): Promise<number>;//#

    /**
     * Get all the values of a hash.
     */
    hvals (key: string, cb?: Callback<string[]>): R;
    hvalsAsync (key: string): Promise<string[]>;//#
    HVALS (key: string, cb?: Callback<string[]>): R;
    HVALSAsync (key: string): Promise<string[]>;//#

    /**
     * Increment the integer value of a key by one.
     */
    incr (key: string, cb?: Callback<string[]>): R;
    incrAsync (key: string): Promise<string[]>;//#
    INCR (key: string, cb?: Callback<string[]>): R;
    INCRAsync (key: string): Promise<string[]>;//#

    /**
     * Increment the integer value of a key by the given amount.
     */
    incrby (key: string, increment: number, cb?: Callback<string[]>): R;
    incrbyAsync (key: string, increment: number): Promise<string[]>;//#
    INCRBY (key: string, increment: number, cb?: Callback<string[]>): R;
    INCRBYAsync (key: string, increment: number): Promise<string[]>;//#

    /**
     * Increment the float value of a key by the given amount.
     */
    incrbyfloat (key: string, increment: number, cb?: Callback<string[]>): R;
    incrbyfloatAsync (key: string, increment: number): Promise<string[]>;//#
    INCRBYFLOAT (key: string, increment: number, cb?: Callback<string[]>): R;
    INCRBYFLOATAsync (key: string, increment: number): Promise<string[]>;//#

    /**
     * Find all keys matching the given pattern.
     */
    keys (pattern: string, cb?: Callback<string[]>): R;
    keysAsync (pattern: string): Promise<string[]>;//#
    KEYS (pattern: string, cb?: Callback<string[]>): R;
    KEYSAsync (pattern: string): Promise<string[]>;//#

    /**
     * Get the UNIX time stamp of the last successful save to disk.
     */
    lastsave (cb?: Callback<number>): R;
    lastsaveAsync (): Promise<number>;//#
    LASTSAVE (cb?: Callback<number>): R;
    LASTSAVEAsync (): Promise<number>;//#

    /**
     * Get an element from a list by its index.
     */
    lindex (key: string, index: number, cb?: Callback<string>): R;
    lindexAsync (key: string, index: number): Promise<string>;//#
    LINDEX (key: string, index: number, cb?: Callback<string>): R;
    LINDEXAsync (key: string, index: number): Promise<string>;//#

    /**
     * Insert an element before or after another element in a list.
     */
    linsert (key: string, dir: 'BEFORE' | 'AFTER', pivot: string, value: string, cb?: Callback<string>): R;
    linsertAsync (key: string, dir: 'BEFORE' | 'AFTER', pivot: string, value: string): Promise<string>;//#
    LINSERT (key: string, dir: 'BEFORE' | 'AFTER', pivot: string, value: string, cb?: Callback<string>): R;
    LINSERTAsync (key: string, dir: 'BEFORE' | 'AFTER', pivot: string, value: string): Promise<string>;//#

    /**
     * Get the length of a list.
     */
    llen (key: string, cb?: Callback<number>): R;
    llenAsync (key: string): Promise<number>;//#
    LLEN (key: string, cb?: Callback<number>): R;
    LLENAsync (key: string): Promise<number>;//#

    /**
     * Remove and get the first element in a list.
     */
    lpop (key: string, cb?: Callback<string>): R;
    lpopAsync (key: string): Promise<string>;//#
    LPOP (key: string, cb?: Callback<string>): R;
    LPOPAsync (key: string): Promise<string>;//#

    /**
     * Prepend one or multiple values to a list.
     */
    lpush: OverloadedKeyCommand<string, number, R>;
    LPUSH: OverloadedKeyCommand<string, number, R>;

    /**
     * Prepend a value to a list, only if the list exists.
     */
    lpushx (key: string, value: string, cb?: Callback<number>): R;
    lpushxAsync (key: string, value: string): Promise<number>;//#
    LPUSHX (key: string, value: string, cb?: Callback<number>): R;
    LPUSHXAsync (key: string, value: string): Promise<number>;//#

    /**
     * Get a range of elements from a list.
     */
    lrange (key: string, start: number, stop: number, cb?: Callback<string[]>): R;
    lrangeAsync (key: string, start: number, stop: number): Promise<string[]>;//#
    LRANGE (key: string, start: number, stop: number, cb?: Callback<string[]>): R;
    LRANGEAsync (key: string, start: number, stop: number): Promise<string[]>;//#

    /**
     * Remove elements from a list.
     */
    lrem (key: string, count: number, value: string, cb?: Callback<number>): R;
    lremAsync (key: string, count: number, value: string): Promise<number>;//#
    LREM (key: string, count: number, value: string, cb?: Callback<number>): R;
    LREMAsync (key: string, count: number, value: string): Promise<number>;//#

    /**
     * Set the value of an element in a list by its index.
     */
    lset (key: string, index: number, value: string, cb?: Callback<'OK'>): R;
    lsetAsync (key: string, index: number, value: string): Promise<'OK'>;//#
    LSET (key: string, index: number, value: string, cb?: Callback<'OK'>): R;
    LSETAsync (key: string, index: number, value: string): Promise<'OK'>;//#

    /**
     * Trim a list to the specified range.
     */
    ltrim (key: string, start: number, stop: number, cb?: Callback<'OK'>): R;
    ltrimAsync (key: string, start: number, stop: number): Promise<'OK'>;//#
    LTRIM (key: string, start: number, stop: number, cb?: Callback<'OK'>): R;
    LTRIMAsync (key: string, start: number, stop: number): Promise<'OK'>;//#

    /**
     * Get the values of all given keys.
     */
    mget: OverloadedCommand<string, string[], R>;
    MGET: OverloadedCommand<string, string[], R>;

    /**
     * Atomically tranfer a key from a Redis instance to another one.
     */
    migrate: OverloadedCommand<string, boolean, R>;
    MIGRATE: OverloadedCommand<string, boolean, R>;

    /**
     * Move a key to another database.
     */
    move (key: string, db: string | number): R;
    MOVE (key: string, db: string | number): R;

    /**
     * Set multiple keys to multiple values.
     */
    mset: OverloadedCommand<string, boolean, R>;
    MSET: OverloadedCommand<string, boolean, R>;

    /**
     * Set multiple keys to multiple values, only if none of the keys exist.
     */
    msetnx: OverloadedCommand<string, boolean, R>;
    MSETNX: OverloadedCommand<string, boolean, R>;

    /**
     * Inspect the internals of Redis objects.
     */
    object: OverloadedCommand<string, any, R>;
    OBJECT: OverloadedCommand<string, any, R>;

    /**
     * Remove the expiration from a key.
     */
    persist (key: string, cb?: Callback<number>): R;
    persistAsync (key: string): Promise<number>;//#
    PERSIST (key: string, cb?: Callback<number>): R;
    PERSISTAsync (key: string): Promise<number>;//#

    /**
     * Remove a key's time to live in milliseconds.
     */
    pexpire (key: string, milliseconds: number, cb?: Callback<number>): R;
    pexpireAsync (key: string, milliseconds: number): Promise<number>;//#
    PEXPIRE (key: string, milliseconds: number, cb?: Callback<number>): R;
    PEXPIREAsync (key: string, milliseconds: number): Promise<number>;//#

    /**
     * Set the expiration for a key as a UNIX timestamp specified in milliseconds.
     */
    pexpireat (key: string, millisecondsTimestamp: number, cb?: Callback<number>): R;
    pexpireatAsync (key: string, millisecondsTimestamp: number): Promise<number>;//#
    PEXPIREAT (key: string, millisecondsTimestamp: number, cb?: Callback<number>): R;
    PEXPIREATAsync (key: string, millisecondsTimestamp: number): Promise<number>;//#

    /**
     * Adds the specified elements to the specified HyperLogLog.
     */
    pfadd: OverloadedKeyCommand<string, number, R>;
    PFADD: OverloadedKeyCommand<string, number, R>;

    /**
     * Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).
     */
    pfcount: OverloadedCommand<string, number, R>;
    PFCOUNT: OverloadedCommand<string, number, R>;

    /**
     * Merge N different HyperLogLogs into a single one.
     */
    pfmerge: OverloadedCommand<string, boolean, R>;
    PFMERGE: OverloadedCommand<string, boolean, R>;

    /**
     * Set the value and expiration in milliseconds of a key.
     */
    psetex (key: string, milliseconds: number, value: string, cb?: Callback<'OK'>): R;
    psetexAsync (key: string, milliseconds: number, value: string): Promise<'OK'>;//#
    PSETEX (key: string, milliseconds: number, value: string, cb?: Callback<'OK'>): R;
    PSETEXAsync (key: string, milliseconds: number, value: string): Promise<'OK'>;//#

    /**
     * Inspect the state of the Pub/Sub subsytem.
     */
    pubsub: OverloadedCommand<string, number, R>;
    PUBSUB: OverloadedCommand<string, number, R>;

    /**
     * Get the time to live for a key in milliseconds.
     */
    pttl (key: string, cb?: Callback<number>): R;
    pttlAsync (key: string): Promise<number>;//#
    PTTL (key: string, cb?: Callback<number>): R;
    PTTLAsync (key: string): Promise<number>;//#

    /**
     * Close the connection.
     */
    quit (cb?: Callback<'OK'>): R;
    quitAsync (): Promise<'OK'>;//#
    QUIT (cb?: Callback<'OK'>): R;
    QUITAsync (): Promise<'OK'>;//#

    /**
     * Return a random key from the keyspace.
     */
    randomkey (cb?: Callback<string>): R;
    randomkeyAsync (): Promise<string>;//#
    RANDOMKEY (cb?: Callback<string>): R;
    RANDOMKEYAsync (): Promise<string>;//#

    /**
     * Enables read queries for a connection to a cluster slave node.
     */
    readonly (cb?: Callback<string>): R;
    readonlyAsync (): Promise<string>;//#
    READONLY (cb?: Callback<string>): R;
    READONLYAsync (): Promise<string>;//#

    /**
     * Disables read queries for a connection to cluster slave node.
     */
    readwrite (cb?: Callback<string>): R;
    readwriteAsync (): Promise<string>;//#
    READWRITE (cb?: Callback<string>): R;
    READWRITEAsync (): Promise<string>;//#

    /**
     * Rename a key.
     */
    rename (key: string, newkey: string, cb?: Callback<'OK'>): R;
    renameAsync (key: string, newkey: string): Promise<'OK'>;//#
    RENAME (key: string, newkey: string, cb?: Callback<'OK'>): R;
    RENAMEAsync (key: string, newkey: string): Promise<'OK'>;//#

    /**
     * Rename a key, only if the new key does not exist.
     */
    renamenx (key: string, newkey: string, cb?: Callback<number>): R;
    renamenxAsync (key: string, newkey: string): Promise<number>;//#
    RENAMENX (key: string, newkey: string, cb?: Callback<number>): R;
    RENAMENXAsync (key: string, newkey: string): Promise<number>;//#

    /**
     * Create a key using the provided serialized value, previously obtained using DUMP.
     */
    restore (key: string, ttl: number, serializedValue: string, cb?: Callback<'OK'>): R;
    restoreAsync (key: string, ttl: number, serializedValue: string): Promise<'OK'>;//#
    RESTORE (key: string, ttl: number, serializedValue: string, cb?: Callback<'OK'>): R;
    RESTOREAsync (key: string, ttl: number, serializedValue: string): Promise<'OK'>;//#

    /**
     * Return the role of the instance in the context of replication.
     */
    role (cb?: Callback<[string, number, Array<[string, string, string]>]>): R;
    roleAsync (): Promise<[string, number, Array<[string, string, string]>;//#
    ROLE (cb?: Callback<[string, number, Array<[string, string, string]>]>): R;
    ROLEAsync (): Promise<[string, number, Array<[string, string, string]>;//#

    /**
     * Remove and get the last element in a list.
     */
    rpop (key: string, cb?: Callback<string>): R;
    rpopAsync (key: string): Promise<string>;//#
    RPOP (key: string, cb?: Callback<string>): R;
    RPOPAsync (key: string): Promise<string>;//#

    /**
     * Remove the last element in a list, prepend it to another list and return it.
     */
    rpoplpush (source: string, destination: string, cb?: Callback<string>): R;
    rpoplpushAsync (source: string, destination: string): Promise<string>;//#
    RPOPLPUSH (source: string, destination: string, cb?: Callback<string>): R;
    RPOPLPUSHAsync (source: string, destination: string): Promise<string>;//#

    /**
     * Append one or multiple values to a list.
     */
    rpush: OverloadedKeyCommand<string, number, R>;
    RPUSH: OverloadedKeyCommand<string, number, R>;

    /**
     * Append a value to a list, only if the list exists.
     */
    rpushx (key: string, value: string, cb?: Callback<number>): R;
    rpushxAsync (key: string, value: string): Promise<number>;//#
    RPUSHX (key: string, value: string, cb?: Callback<number>): R;
    RPUSHXAsync (key: string, value: string): Promise<number>;//#

    /**
     * Append one or multiple members to a set.
     */
    sadd: OverloadedKeyCommand<string, number, R>;
    SADD: OverloadedKeyCommand<string, number, R>;

    /**
     * Synchronously save the dataset to disk.
     */
    save (cb?: Callback<string>): R;
    saveAsync (): Promise<string>;//#
    SAVE (cb?: Callback<string>): R;
    SAVEAsync (): Promise<string>;//#

    /**
     * Get the number of members in a set.
     */
    scard (key: string, cb?: Callback<number>): R;
    scardAsync (key: string): Promise<number>;//#
    SCARD (key: string, cb?: Callback<number>): R;
    SCARDAsync (key: string): Promise<number>;//#

    /**
     * DEBUG - Set the debug mode for executed scripts.
     * EXISTS - Check existence of scripts in the script cache.
     * FLUSH - Remove all scripts from the script cache.
     * KILL - Kill the script currently in execution.
     * LOAD - Load the specified Lua script into the script cache.
     */
    script: OverloadedCommand<string, any, R>;
    SCRIPT: OverloadedCommand<string, any, R>;

    /**
     * Subtract multiple sets.
     */
    sdiff: OverloadedCommand<string, string[], R>;
    SDIFF: OverloadedCommand<string, string[], R>;

    /**
     * Subtract multiple sets and store the resulting set in a key.
     */
    sdiffstore: OverloadedKeyCommand<string, number, R>;
    SDIFFSTORE: OverloadedKeyCommand<string, number, R>;

    /**
     * Change the selected database for the current connection.
     */
    select (index: number | string, cb?: Callback<string>): R;
    selectAsync (index: number | string): Promise<string>;//#
    SELECT (index: number | string, cb?: Callback<string>): R;
    SELECTAsync (index: number | string): Promise<string>;//#

    /**
     * Set the string value of a key.
     */
    set (key: string, value: string, cb?: Callback<'OK'>): R;
    setAsync (key: string, value: string): Promise<'OK'>;//#
    set (key: string, value: string, flag: string, cb?: Callback<'OK'>): R;
    setAsync (key: string, value: string, flag: string): Promise<'OK'>;//#
    set (key: string, value: string, mode: string, duration: number, cb?: Callback<'OK' | void>): R;
    setAsync (key: string, value: string, mode: string, duration: number): Promise<'OK' | void>;//#
    set (key: string, value: string, mode: string, duration: number, flag: string, cb?: Callback<'OK' | void>): R;
    setAsync (key: string, value: string, mode: string, duration: number, flag: string): Promise<'OK' | void>;//#
    SET (key: string, value: string, cb?: Callback<'OK'>): R;
    SETAsync (key: string, value: string): Promise<'OK'>;//#
    SET (key: string, value: string, flag: string, cb?: Callback<'OK'>): R;
    SETAsync (key: string, value: string, flag: string): Promise<'OK'>;//#
    SET (key: string, value: string, mode: string, duration: number, cb?: Callback<'OK' | void>): R;
    SETAsync (key: string, value: string, mode: string, duration: number): Promise<'OK' | void>;//#
    SET (key: string, value: string, mode: string, duration: number, flag: string, cb?: Callback<'OK' | void>): R;
    SETAsync (key: string, value: string, mode: string, duration: number, flag: string): Promise<'OK' | void>;//#

    /**
     * Sets or clears the bit at offset in the string value stored at key.
     */
    setbit (key: string, offset: number, value: string, cb?: Callback<number>): R;
    setbitAsync (key: string, offset: number, value: string): Promise<number>;//#
    SETBIT (key: string, offset: number, value: string, cb?: Callback<number>): R;
    SETBITAsync (key: string, offset: number, value: string): Promise<number>;//#

    /**
     * Set the value and expiration of a key.
     */
    setex (key: string, seconds: number, value: string, cb?: Callback<string>): R;
    setexAsync (key: string, seconds: number, value: string): Promise<string>;//#
    SETEX (key: string, seconds: number, value: string, cb?: Callback<string>): R;
    SETEXAsync (key: string, seconds: number, value: string): Promise<string>;//#

    /**
     * Set the value of a key, only if the key does not exist.
     */
    setnx (key: string, value: string, cb?: Callback<number>): R;
    setnxAsync (key: string, value: string): Promise<number>;//#
    SETNX (key: string, value: string, cb?: Callback<number>): R;
    SETNXAsync (key: string, value: string): Promise<number>;//#

    /**
     * Overwrite part of a string at key starting at the specified offset.
     */
    setrange (key: string, offset: number, value: string, cb?: Callback<number>): R;
    setrangeAsync (key: string, offset: number, value: string): Promise<number>;//#
    SETRANGE (key: string, offset: number, value: string, cb?: Callback<number>): R;
    SETRANGEAsync (key: string, offset: number, value: string): Promise<number>;//#

    /**
     * Synchronously save the dataset to disk and then shut down the server.
     */
    shutdown: OverloadedCommand<string, string, R>;
    SHUTDOWN: OverloadedCommand<string, string, R>;

    /**
     * Intersect multiple sets.
     */
    sinter: OverloadedKeyCommand<string, string[], R>;
    SINTER: OverloadedKeyCommand<string, string[], R>;

    /**
     * Intersect multiple sets and store the resulting set in a key.
     */
    sinterstore: OverloadedCommand<string, number, R>;
    SINTERSTORE: OverloadedCommand<string, number, R>;

    /**
     * Determine if a given value is a member of a set.
     */
    sismember (key: string, member: string, cb?: Callback<number>): R;
    sismemberAsync (key: string, member: string): Promise<number>;//#
    SISMEMBER (key: string, member: string, cb?: Callback<number>): R;
    SISMEMBERAsync (key: string, member: string): Promise<number>;//#

    /**
     * Make the server a slave of another instance, or promote it as master.
     */
    slaveof (host: string, port: string | number, cb?: Callback<string>): R;
    slaveofAsync (host: string, port: string | number): Promise<string>;//#
    SLAVEOF (host: string, port: string | number, cb?: Callback<string>): R;
    SLAVEOFAsync (host: string, port: string | number): Promise<string>;//#

    /**
     * Manages the Redis slow queries log.
     */
    slowlog: OverloadedCommand<string, Array<[number, number, number, string[]]>, R>;
    SLOWLOG: OverloadedCommand<string, Array<[number, number, number, string[]]>, R>;

    /**
     * Get all the members in a set.
     */
    smembers (key: string, cb?: Callback<string[]>): R;
    smembersAsync (key: string): Promise<string[]>;//#
    SMEMBERS (key: string, cb?: Callback<string[]>): R;
    SMEMBERSAsync (key: string): Promise<string[]>;//#

    /**
     * Move a member from one set to another.
     */
    smove (source: string, destination: string, member: string, cb?: Callback<number>): R;
    smoveAsync (source: string, destination: string, member: string): Promise<number>;//#
    SMOVE (source: string, destination: string, member: string, cb?: Callback<number>): R;
    SMOVEAsync (source: string, destination: string, member: string): Promise<number>;//#

    /**
     * Sort the elements in a list, set or sorted set.
     */
    sort: OverloadedCommand<string, string[], R>;
    SORT: OverloadedCommand<string, string[], R>;

    /**
     * Remove and return one or multiple random members from a set.
     */
    spop (key: string, cb?: Callback<string>): R;
    spopAsync (key: string): Promise<string>;//#
    spop (key: string, count: number, cb?: Callback<string[]>): R;
    spopAsync (key: string, count: number): Promise<string[]>;//#
    SPOP (key: string, cb?: Callback<string>): R;
    SPOPAsync (key: string): Promise<string>;//#
    SPOP (key: string, count: number, cb?: Callback<string[]>): R;
    SPOPAsync (key: string, count: number): Promise<string[]>;//#

    /**
     * Get one or multiple random members from a set.
     */
    srandmember (key: string, cb?: Callback<string>): R;
    srandmemberAsync (key: string): Promise<string>;//#
    srandmember (key: string, count: number, cb?: Callback<string[]>): R;
    srandmemberAsync (key: string, count: number): Promise<string[]>;//#
    SRANDMEMBER (key: string, cb?: Callback<string>): R;
    SRANDMEMBERAsync (key: string): Promise<string>;//#
    SRANDMEMBER (key: string, count: number, cb?: Callback<string[]>): R;
    SRANDMEMBERAsync (key: string, count: number): Promise<string[]>;//#

    /**
     * Remove one or more members from a set.
     */
    srem: OverloadedKeyCommand<string, number, R>;
    SREM: OverloadedKeyCommand<string, number, R>;

    /**
     * Get the length of the value stored in a key.
     */
    strlen (key: string, cb?: Callback<number>): R;
    strlenAsync (key: string): Promise<number>;//#
    STRLEN (key: string, cb?: Callback<number>): R;
    STRLENAsync (key: string): Promise<number>;//#

    /**
     * Add multiple sets.
     */
    sunion: OverloadedCommand<string, string[], R>;
    SUNION: OverloadedCommand<string, string[], R>;

    /**
     * Add multiple sets and store the resulting set in a key.
     */
    sunionstore: OverloadedCommand<string, number, R>;
    SUNIONSTORE: OverloadedCommand<string, number, R>;

    /**
     * Internal command used for replication.
     */
    sync (cb?: Callback<void>): R;
    syncAsync (): Promise<void>;//#
    SYNC (cb?: Callback<void>): R;
    SYNCAsync (): Promise<void>;//#

    /**
     * Return the current server time.
     */
    sync (cb?: Callback<[string, string]>): R;
    syncAsync (): Promise<[string, string]>;//#
    SYNC (cb?: Callback<[string, string]>): R;
    SYNCAsync (): Promise<[string, string]>;//#

    /**
     * Get the time to live for a key.
     */
    ttl (key: string, cb?: Callback<number>): R;
    ttlAsync (key: string): Promise<number>;//#
    TTL (key: string, cb?: Callback<number>): R;
    TTLAsync (key: string): Promise<number>;//#

    /**
     * Determine the type stored at key.
     */
    type (key: string, cb?: Callback<string>): R;
    typeAsync (key: string): Promise<string>;//#
    TYPE (key: string, cb?: Callback<string>): R;
    TYPEAsync (key: string): Promise<string>;//#

    /**
     * Forget about all watched keys.
     */
    unwatch (cb?: Callback<'OK'>): R;
    unwatchAsync (): Promise<'OK'>;//#
    UNWATCH (cb?: Callback<'OK'>): R;
    UNWATCHAsync (): Promise<'OK'>;//#

    /**
     * Wait for the synchronous replication of all the write commands sent in the context of the current connection.
     */
    wait (numslaves: number, timeout: number, cb?: Callback<number>): R;
    waitAsync (numslaves: number, timeout: number): Promise<number>;//#
    WAIT (numslaves: number, timeout: number, cb?: Callback<number>): R;
    WAITAsync (numslaves: number, timeout: number): Promise<number>;//#

    /**
     * Watch the given keys to determine execution of the MULTI/EXEC block.
     */
    watch: OverloadedCommand<string, 'OK', R>;
    WATCH: OverloadedCommand<string, 'OK', R>;

    /**
     * Add one or more members to a sorted set, or update its score if it already exists.
     */
    zadd: OverloadedKeyCommand<string | number, number, R>;
    ZADD: OverloadedKeyCommand<string | number, number, R>;

    /**
     * Get the number of members in a sorted set.
     */
    zcard (key: string, cb?: Callback<number>): R;
    zcardAsync (key: string): Promise<number>;//#
    ZCARD (key: string, cb?: Callback<number>): R;
    ZCARDAsync (key: string): Promise<number>;//#

    /**
     * Count the members in a sorted set with scores between the given values.
     */
    zcount (key: string, min: number | string, max: number | string, cb?: Callback<number>): R;
    zcountAsync (key: string, min: number | string, max: number | string): Promise<number>;//#
    ZCOUNT (key: string, min: number | string, max: number | string, cb?: Callback<number>): R;
    ZCOUNTAsync (key: string, min: number | string, max: number | string): Promise<number>;//#

    /**
     * Increment the score of a member in a sorted set.
     */
    zincrby (key: string, increment: number, member: string, cb?: Callback<number>): R;
    zincrbyAsync (key: string, increment: number, member: string): Promise<number>;//#
    ZINCRBY (key: string, increment: number, member: string, cb?: Callback<number>): R;
    ZINCRBYAsync (key: string, increment: number, member: string): Promise<number>;//#

    /**
     * Intersect multiple sorted sets and store the resulting sorted set in a new key.
     */
    zinterstore: OverloadedCommand<string | number, number, R>;
    ZINTERSTORE: OverloadedCommand<string | number, number, R>;

    /**
     * Count the number of members in a sorted set between a given lexicographic range.
     */
    zlexcount (key: string, min: string, max: string, cb?: Callback<number>): R;
    zlexcountAsync (key: string, min: string, max: string): Promise<number>;//#
    ZLEXCOUNT (key: string, min: string, max: string, cb?: Callback<number>): R;
    ZLEXCOUNTAsync (key: string, min: string, max: string): Promise<number>;//#

    /**
     * Return a range of members in a sorted set, by index.
     */
    zrange (key: string, start: number, stop: number, cb?: Callback<string[]>): R;
    zrangeAsync (key: string, start: number, stop: number): Promise<string[]>;//#
    zrange (key: string, start: number, stop: number, withscores: string, cb?: Callback<string[]>): R;
    zrangeAsync (key: string, start: number, stop: number, withscores: string): Promise<string[]>;//#
    ZRANGE (key: string, start: number, stop: number, cb?: Callback<string[]>): R;
    ZRANGEAsync (key: string, start: number, stop: number): Promise<string[]>;//#
    ZRANGE (key: string, start: number, stop: number, withscores: string, cb?: Callback<string[]>): R;
    ZRANGEAsync (key: string, start: number, stop: number, withscores: string): Promise<string[]>;//#

    /**
     * Return a range of members in a sorted set, by lexicographical range.
     */
    zrangebylex (key: string, min: string, max: string, cb?: Callback<string[]>): R;
    zrangebylexAsync (key: string, min: string, max: string): Promise<string[]>;//#
    zrangebylex (key: string, min: string, max: string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    zrangebylexAsync (key: string, min: string, max: string, limit: string, offset: number, count: number): Promise<string[]>;//#
    ZRANGEBYLEX (key: string, min: string, max: string, cb?: Callback<string[]>): R;
    ZRANGEBYLEXAsync (key: string, min: string, max: string): Promise<string[]>;//#
    ZRANGEBYLEX (key: string, min: string, max: string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    ZRANGEBYLEXAsync (key: string, min: string, max: string, limit: string, offset: number, count: number): Promise<string[]>;//#

    /**
     * Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.
     */
    zrevrangebylex (key: string, min: string, max: string, cb?: Callback<string[]>): R;
    zrevrangebylexAsync (key: string, min: string, max: string): Promise<string[]>;//#
    zrevrangebylex (key: string, min: string, max: string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    zrevrangebylexAsync (key: string, min: string, max: string, limit: string, offset: number, count: number): Promise<string[]>;//#
    ZREVRANGEBYLEX (key: string, min: string, max: string, cb?: Callback<string[]>): R;
    ZREVRANGEBYLEXAsync (key: string, min: string, max: string): Promise<string[]>;//#
    ZREVRANGEBYLEX (key: string, min: string, max: string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    ZREVRANGEBYLEXAsync (key: string, min: string, max: string, limit: string, offset: number, count: number): Promise<string[]>;//#

    /**
     * Return a range of members in a sorted set, by score.
     */
    zrangebyscore (key: string, min: number | string, max: number | string, cb?: Callback<string[]>): R;
    zrangebyscoreAsync (key: string, min: number | string, max: number | string): Promise<string[]>;//#
    zrangebyscore (key: string, min: number | string, max: number | string, withscores: string, cb?: Callback<string[]>): R;
    zrangebyscoreAsync (key: string, min: number | string, max: number | string, withscores: string): Promise<string[]>;//#
    zrangebyscore (key: string, min: number | string, max: number | string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    zrangebyscoreAsync (key: string, min: number | string, max: number | string, limit: string, offset: number, count: number): Promise<string[]>;//#
    zrangebyscore (key: string, min: number | string, max: number | string, withscores: string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    zrangebyscoreAsync (key: string, min: number | string, max: number | string, withscores: string, limit: string, offset: number, count: number): Promise<string[]>;//#
    ZRANGEBYSCORE (key: string, min: number | string, max: number | string, cb?: Callback<string[]>): R;
    ZRANGEBYSCOREAsync (key: string, min: number | string, max: number | string): Promise<string[]>;//#
    ZRANGEBYSCORE (key: string, min: number | string, max: number | string, withscores: string, cb?: Callback<string[]>): R;
    ZRANGEBYSCOREAsync (key: string, min: number | string, max: number | string, withscores: string): Promise<string[]>;//#
    ZRANGEBYSCORE (key: string, min: number | string, max: number | string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    ZRANGEBYSCOREAsync (key: string, min: number | string, max: number | string, limit: string, offset: number, count: number): Promise<string[]>;//#
    ZRANGEBYSCORE (key: string, min: number | string, max: number | string, withscores: string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    ZRANGEBYSCOREAsync (key: string, min: number | string, max: number | string, withscores: string, limit: string, offset: number, count: number): Promise<string[]>;//#

    /**
     * Determine the index of a member in a sorted set.
     */
    zrank (key: string, member: string, cb?: Callback<number | void>): R;
    zrankAsync (key: string, member: string): Promise<number | void>;//#
    ZRANK (key: string, member: string, cb?: Callback<number | void>): R;
    ZRANKAsync (key: string, member: string): Promise<number | void>;//#

    /**
     * Remove one or more members from a sorted set.
     */
    zrem: OverloadedKeyCommand<string, number, R>;
    ZREM: OverloadedKeyCommand<string, number, R>;

    /**
     * Remove all members in a sorted set between the given lexicographical range.
     */
    zremrangebylex (key: string, min: string, max: string, cb?: Callback<number>): R;
    zremrangebylexAsync (key: string, min: string, max: string): Promise<number>;//#
    ZREMRANGEBYLEX (key: string, min: string, max: string, cb?: Callback<number>): R;
    ZREMRANGEBYLEXAsync (key: string, min: string, max: string): Promise<number>;//#

    /**
     * Remove all members in a sorted set within the given indexes.
     */
    zremrangebyrank (key: string, start: number, stop: number, cb?: Callback<number>): R;
    zremrangebyrankAsync (key: string, start: number, stop: number): Promise<number>;//#
    ZREMRANGEBYRANK (key: string, start: number, stop: number, cb?: Callback<number>): R;
    ZREMRANGEBYRANKAsync (key: string, start: number, stop: number): Promise<number>;//#

    /**
     * Remove all members in a sorted set within the given indexes.
     */
    zremrangebyscore (key: string, min: string | number, max: string | number, cb?: Callback<number>): R;
    zremrangebyscoreAsync (key: string, min: string | number, max: string | number): Promise<number>;//#
    ZREMRANGEBYSCORE (key: string, min: string | number, max: string | number, cb?: Callback<number>): R;
    ZREMRANGEBYSCOREAsync (key: string, min: string | number, max: string | number): Promise<number>;//#

    /**
     * Return a range of members in a sorted set, by index, with scores ordered from high to low.
     */
    zrevrange (key: string, start: number, stop: number, cb?: Callback<string[]>): R;
    zrevrangeAsync (key: string, start: number, stop: number): Promise<string[]>;//#
    zrevrange (key: string, start: number, stop: number, withscores: string, cb?: Callback<string[]>): R;
    zrevrangeAsync (key: string, start: number, stop: number, withscores: string): Promise<string[]>;//#
    ZREVRANGE (key: string, start: number, stop: number, cb?: Callback<string[]>): R;
    ZREVRANGEAsync (key: string, start: number, stop: number): Promise<string[]>;//#
    ZREVRANGE (key: string, start: number, stop: number, withscores: string, cb?: Callback<string[]>): R;
    ZREVRANGEAsync (key: string, start: number, stop: number, withscores: string): Promise<string[]>;//#

    /**
     * Return a range of members in a sorted set, by score, with scores ordered from high to low.
     */
    zrevrangebyscore (key: string, min: number | string, max: number | string, cb?: Callback<string[]>): R;
    zrevrangebyscoreAsync (key: string, min: number | string, max: number | string): Promise<string[]>;//#
    zrevrangebyscore (key: string, min: number | string, max: number | string, withscores: string, cb?: Callback<string[]>): R;
    zrevrangebyscoreAsync (key: string, min: number | string, max: number | string, withscores: string): Promise<string[]>;//#
    zrevrangebyscore (key: string, min: number | string, max: number | string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    zrevrangebyscoreAsync (key: string, min: number | string, max: number | string, limit: string, offset: number, count: number): Promise<string[]>;//#
    zrevrangebyscore (key: string, min: number | string, max: number | string, withscores: string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    zrevrangebyscoreAsync (key: string, min: number | string, max: number | string, withscores: string, limit: string, offset: number, count: number): Promise<string[]>;//#
    ZREVRANGEBYSCORE (key: string, min: number | string, max: number | string, cb?: Callback<string[]>): R;
    ZREVRANGEBYSCOREAsync (key: string, min: number | string, max: number | string): Promise<string[]>;//#
    ZREVRANGEBYSCORE (key: string, min: number | string, max: number | string, withscores: string, cb?: Callback<string[]>): R;
    ZREVRANGEBYSCOREAsync (key: string, min: number | string, max: number | string, withscores: string): Promise<string[]>;//#
    ZREVRANGEBYSCORE (key: string, min: number | string, max: number | string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    ZREVRANGEBYSCOREAsync (key: string, min: number | string, max: number | string, limit: string, offset: number, count: number): Promise<string[]>;//#
    ZREVRANGEBYSCORE (key: string, min: number | string, max: number | string, withscores: string, limit: string, offset: number, count: number, cb?: Callback<string[]>): R;
    ZREVRANGEBYSCOREAsync (key: string, min: number | string, max: number | string, withscores: string, limit: string, offset: number, count: number): Promise<string[]>;//#

    /**
     * Determine the index of a member in a sorted set, with scores ordered from high to low.
     */
    zrevrank (key: string, member: string, cb?: Callback<number | void>): R;
    zrevrankAsync (key: string, member: string): Promise<number | void>;//#
    ZREVRANK (key: string, member: string, cb?: Callback<number | void>): R;
    ZREVRANKAsync (key: string, member: string): Promise<number | void>;//#

    /**
     * Get the score associated with the given member in a sorted set.
     */
    zscore (key: string, member: string, cb?: Callback<string>): R;
    zscoreAsync (key: string, member: string): Promise<string>;//#
    ZSCORE (key: string, member: string, cb?: Callback<string>): R;
    ZSCOREAsync (key: string, member: string): Promise<string>;//#

    /**
     * Add multiple sorted sets and store the resulting sorted set in a new key.
     */
    zunionstore: OverloadedCommand<string | number, number, R>;
    ZUNIONSTORE: OverloadedCommand<string | number, number, R>;

    /**
     * Incrementally iterate the keys space.
     */
    scan: OverloadedCommand<string, [string, string[]], R>;
    SCAN: OverloadedCommand<string, [string, string[]], R>;

    /**
     * Incrementally iterate Set elements.
     */
    sscan: OverloadedKeyCommand<string, [string, string[]], R>;
    SSCAN: OverloadedKeyCommand<string, [string, string[]], R>;

    /**
     * Incrementally iterate hash fields and associated values.
     */
    hscan: OverloadedKeyCommand<string, [string, string[]], R>;
    HSCAN: OverloadedKeyCommand<string, [string, string[]], R>;

    /**
     * Incrementally iterate sorted sets elements and associated scores.
     */
    zscan: OverloadedKeyCommand<string, [string, string[]], R>;
    ZSCAN: OverloadedKeyCommand<string, [string, string[]], R>;
  }

  export var RedisClient: {
    new (options: ClientOptions): RedisClient;
  };

  export interface RedisClient extends Commands<boolean>, EventEmitter {
    connected: boolean;
    command_queue_length: number;
    offline_queue_length: number;
    retry_delay: number;
    retry_backoff: number;
    command_queue: any[];
    offline_queue: any[];
    connection_id: number;
    server_info: ServerInfo;
    stream: Duplex;

    on (event: 'message', listener: (channel: string, message: string) => void): this;
    on (event: 'pmessage', listener: (pattern: string, channel: string, message: string) => void): this;
    on (event: 'message_buffer', listener: (channel: string, message: string) => void): this;
    on (event: 'pmessage_buffer', listener: (pattern: string, channel: string, message: string) => void): this;
    on (event: 'subscribe', listener: (channel: string, count: number) => void): this;
    on (event: 'psubscribe', listener: (pattern: string, count: number) => void): this;
    on (event: 'unsubscribe', listener: (channel: string, count: number) => void): this;
    on (event: 'punsubscribe', listener: (pattern: string, count: number) => void): this;
    on (event: string, listener: (...args: any[]) => void): this;

    /**
     * Client methods.
     */

    end (flush?: boolean): void;
    unref (): void;

    duplicate (options?: ClientOptions, cb?: Callback<RedisClient>): RedisClient;
    duplicateAsync (options?: ClientOptions): Promise<RedisClient>;//#

    sendCommand (command: string, cb?: Callback<any>): boolean;
    sendCommandAsync (command: string): Promise<any>;//#
    sendCommand (command: string, args?: any[], cb?: Callback<any>): boolean;
    sendCommandAsync (command: string, args?: any[]): Promise<any>;//#
    send_command (command: string, cb?: Callback<any>): boolean;
    send_commandAsync (command: string): Promise<any>;//#
    send_command (command: string, args?: any[], cb?: Callback<any>): boolean;
    send_commandAsync (command: string, args?: any[]): Promise<any>;//#

    /**
     * Mark the start of a transaction block.
     */
    multi (args?: Array<Array<string | number | Callback<any>>>): Multi;
    MULTI (args?: Array<Array<string | number | Callback<any>>>): Multi;

    batch (args?: Array<Array<string | number | Callback<any>>>): Multi;
    BATCH (args?: Array<Array<string | number | Callback<any>>>): Multi;
  }

  export var Multi: {
    new (): Multi;
  };

  export interface Multi extends Commands<Multi> {
    exec (cb: Callback<any[]>): boolean;
    execAsync (): Promise<any[]>;//#
    EXEC (cb: Callback<any[]>): boolean;
    EXECAsync (): Promise<any[]>;//#

    exec_atomic (cb: Callback<any[]>): boolean;
    exec_atomicAsync (): Promise<any[]>;//#
    EXEC_ATOMIC (cb: Callback<any[]>): boolean;
    EXEC_ATOMICAsync (): Promise<any[]>;//#
  }

  export var debug_mode: boolean;

  export function createClient (port: number, host?: string, options?: ClientOptions): RedisClient;
  export function createClient (unix_socket: string, options?: ClientOptions): RedisClient;
  export function createClient (redis_url: string, options?: ClientOptions): RedisClient;
  export function createClient (options?: ClientOptions): RedisClient;

  export function print (err: Error | void, reply: any): void;
}

export = redis;
}
